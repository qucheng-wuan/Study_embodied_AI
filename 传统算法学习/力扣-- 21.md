[21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)
将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
![[Pasted image 20251003195100.png]]
代码：
**（有空结点的）**
```
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        // 方法1：迭代法
        ListNode* dummy = new ListNode(0);  // 虚拟头节点
        ListNode* cur = dummy;              // 当前指针
        
        // 比较两个链表的节点值，选择较小的连接
        while(list1 != nullptr && list2 != nullptr) {
            if(list1->val <= list2->val) {
                cur->next = list1;
                list1 = list1->next;
            } else {
                cur->next = list2;
                list2 = list2->next;
            }
            cur = cur->next;
        }
        
        // 连接剩余节点
        cur->next = (list1 != nullptr) ? list1 : list2;
        
        // 返回结果（跳过虚拟头节点）
        ListNode* result = dummy->next;
        delete dummy;  // 释放虚拟节点内存
        return result;
    }
};
```
**无空结点的**
```
class Solution {

public:

ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {

if(!list1) return list2;

if(!list2) return list1;

  

ListNode* head;

ListNode* cur;

  

if(list1->val <= list2->val){

head = list1;

list1 = list1->next;

}else{

head = list2;

list2 = list2->next;

}

cur = head;

  

// 后续节点正常比较连接

while (list1 != nullptr && list2 != nullptr) {

if (list1->val <= list2->val) {

cur->next = list1;

list1 = list1->next;

} else {

cur->next = list2;

list2 = list2->next;

}

cur = cur->next;

}

  

cur->next = (list1!= nullptr)? list1:list2;

return head;

}

};
```