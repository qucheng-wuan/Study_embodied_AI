[160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)
给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。
图示两个链表在节点 `c1` 开始相交：

[![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

代码：
**双指针法**
你可以理解 双指针 这个合并链表长度相等
链表A + 链表B：A1→A2→C1→C2→B1→B2→B3→C1→C2
链表B + 链表A：B1→B2→B3→C1→C2→A1→A2→C1→C2

> 第1步: pA=A1, pB=B1  (不相等，继续)
> 第2步: pA=A2, pB=B2  (不相等，继续)  
> 第3步: pA=C1, pB=B3  (不相等，继续)
> 第4步: pA=C2, pB=C1  (不相等，继续)
> 第5步: pA=C3, pB=C2  (不相等，继续)
> 第6步: pA=null, pB=C3  (pA到头了，跳到headB)
>       现在: pA=B1, pB=C3
> 第7步: pA=B2, pB=null (pB到头了，跳到headA)  
>       现在: pA=B2, pB=A1
> 第8步: pA=B3, pB=A2
> 第9步: pA=C1, pB=C1  ← 相遇！这就是相交点
```
/**

* Definition for singly-linked list.

* struct ListNode {

* int val;

* ListNode *next;

* ListNode(int x) : val(x), next(NULL) {}

* };

*/

class Solution {

public:

ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {

ListNode*pa = headA;

ListNode*pb = headB;

  

while(pa!=pb){

pa = pa ?pa->next:headB;

pb = pb ?pb->next:headA;

}

return pa;

}

};
```

==链表是单向的 每一个结点只能有一个指针==
我们说的是找到了相同的结点对象不是节点值。

方法二：哈希集合
明确几个哈希的格式
```
// 创建一个哈希表
unordered_set<ListNode*> visited;  // 这是一个记录节点的"查找本"

// 往"查找本"里添加东西
visited.insert(某个节点);  // 记录这个节点

// 查看"查找本"里是否有某个东西
visited.count(某个节点);   // 如果有返回1，没有返回0

```

```
/**

* Definition for singly-linked list.

* struct ListNode {

* int val;

* ListNode *next;

* ListNode(int x) : val(x), next(NULL) {}

* };

*/

class Solution {

public:

ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {

unordered_set<ListNode*> visited;

  

ListNode* temp = headA;

while(temp!= nullptr){

visited.insert(temp);

temp=temp->next;

}

  

temp = headB;

while(temp!=nullptr){

if(visited.count(temp)){

return temp;

}

temp = temp->next;

}

return nullptr;

}

};
```